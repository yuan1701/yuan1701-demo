1.call和apply
    作用：改变this指向，区别：传参不同
2、闭包
    闭包的使用场景：
        a.函数作为返回值
        b.函数作为参数传递
    用闭包有什么好处？
        1. 延长作用域链。
        2. 生成预编译函数。
        3.更好的组织代码，比如模块化，异步代码转同步等。
        4. 处理异步造成的变量不能即时传递的问题
    闭包又有什么坏处？
        1.  增加了内存的消耗。
        2.  某些浏览器上因为回收机制的问题，有内存溢出风险。
        3.  增加了代码的复杂度，维护和调试不便。
3、this
    谁调用就指向谁
    扩展：this的使用场景
    1.作为构造函数执行
    2.作为对象属性执行
    3.作为普通函数执行
    4.call apply bind
4、作用域
    js没有块级作用域，只有全局和函数作用域
5、执行上下文
6.三次捂手
7.http协议
8.es6新特性
    1.let和const    let声明的变量只在let命令所在的代码块有效，let没有变量提升，不允许重复声明
    2.模板字符串
    3.函数默认参数 箭头函数  箭头函数没有自己的this而是引用外层的this。
    4.解构
    5. ...操作符   展开操作符   剩余操作符
    6.class、 extends、 super
    子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。父类的静态方法，也会被子类继承。
    super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。
    作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错
    第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。
    7.Promise
    8.Set
    9.import 和 export


9.校验电话号码对不对



同源：协议。ip,端口
1.把 GET 和 POST 类型的 AJAX 的用法手写一遍？
2. 封装一个 AJAX 函数？
3.闭包
    闭包：能够读取其他函数内部变量的函数
    作用：一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在f1调用后被自动清除。

4.new 本质：创建实例，初始化实例，返回实例
5.reduce()函数
6.Object.prototype.toString.call()
7.有如下代码，解释 Person、 prototype、__proto__、p、constructor 之间的关联：
    function Person(name){
      this.name = name;
    }
    Person.prototype.sayName = function(){
      console.log('My name is :' + this.name);
    }
    var p = new Person("Oli")
    p.sayName();

8.box-sizing的两个属性
    box-sizing: border-box  
    box-sizing: content-box;



